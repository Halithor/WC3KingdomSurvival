package GenerateTerrain

import Globals
import TerrainTypes
import LinkedList
import ClosureTimers
import HashList
import HashSet

/** The size of a tile, for x,y and z */
constant TILE_SIZE = 128.0
constant PATHING_INCREMENT = 32.0

constant TERRAIN_LORDAERON_SUM_DIR = 'Ldrt'

constant mapSize = 128
constant playRadius = mapPlayAreaRadius

constant deformInterval = 128.0
constant riverRadius = 512.0
constant riverDepth = 32.0

constant sideOffsets = 128.0 * 1.2

constant terrainVariationCount = 90
constant characterMaxDistance = 128.0 * 5

constant treeId = 'LTlt'
constant treeCount = 30
constant treeOffsetCount = 4
constant treeOffsetDist = 128.0 * treeOffsetCount

constant mineId = 'LTrc'
constant mineCount = 30
constant mineOffsetCount = 3
constant mineOffsetDist = 128.0 * mineOffsetCount
constant mineDestRemoveRadius = 96.0

constant genMinNodeRadius = 6
constant genMaxNodeRadius = 9
constant neighborExtraRadius = 10

class Node
    // Node radius, in tiles
    int radius = 0
    // the center of this node
    int x
    int y

    // Nodes to link to this one
    LinkedList<Node> adjacent

    construct(int x, int y)
        this.x = x
        this.y = y
        adjacent = new LinkedList<Node>()
    
    construct(int x, int y, int radius)
        this.x = x
        this.y = y
        adjacent = new LinkedList<Node>()
        this.radius = radius

    function getPos() returns vec2
        return vec2(x.toReal(), y.toReal())
    
    function getMapPos() returns vec2
        return getPos() * TILE_SIZE
        
LinkedList<Node> nodes = new LinkedList<Node>()

public function generateTerrain()
    hideAllWater()

    // Setup the initial big splotches 
    
    
    // throw some variation down
    // for i = 0 to terrainVariationCount
    //     let start = camRect.randomPoint()
    //     let target = start.polarOffset(GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(128.0, characterMaxDistance))
    //     for offset = 0 to (start.distanceTo(target) / 128.0).round()
    //         let pos = start.moveTowards(target, offset * 128.0)
    //         SetTerrainType(pos.x, pos.y, 'Ldro', -1, GetRandomInt(1, 3), 0)
    // for i = 0 to terrainVariationCount
    //     let start = camRect.randomPoint()
    //     let target = start.polarOffset(GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(128.0, characterMaxDistance))
    //     for offset = 0 to (start.distanceTo(target) / 128.0).round()
    //         let pos = start.moveTowards(target, offset * 128.0)
    //         SetTerrainType(pos.x, pos.y, 'Ldrg', -1, GetRandomInt(1, 3), 0)
    // for i = 0 to terrainVariationCount
    //     let start = camRect.randomPoint()
    //     let target = start.polarOffset(GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(128.0, characterMaxDistance))
    //     for offset = 0 to (start.distanceTo(target) / 128.0).round()
    //         let pos = start.moveTowards(target, offset * 128.0)
    //         SetTerrainType(pos.x, pos.y, 'Lgrs', -1, GetRandomInt(1, 3), 0)
    // // Place the trees
    // for i = 1 to treeCount
    //     let start = kRect_PlayArea.randomPoint()
    //     let final = start.polarOffset(GetRandomDirectionDeg().asAngleDegrees(), treeOffsetDist)
    //     for offset = 0 to treeOffsetCount
    //         let pos = start.moveTowards(final, 128.0 * offset)
    //         CreateDestructableZ(treeId, pos.x, pos.y, 128.0, GetRandomDirectionDeg().asAngleDegrees().radians(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //         // createDestructable(treeId, pos, GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //         SetTerrainType(pos.x, pos.y, 'Lgrd', -1, 3, 0)
    //         if GetRandomReal(0, 1) < 0.75
    //             let posLeft = pos.polarOffset(start.angleTo(final) + (90).asAngleDegrees(), sideOffsets)
    //             CreateDestructableZ(treeId, pos.x, pos.y, 128.0, GetRandomDirectionDeg().asAngleDegrees().radians(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //             // createDestructable(treeId, posLeft, GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //             SetTerrainType(posLeft.x, posLeft.y, 'Lgrd', -1, 2, 0)
    //         if GetRandomReal(0, 1) < 0.75
    //             let posRight = pos.polarOffset(start.angleTo(final) + (90).asAngleDegrees(), sideOffsets)
    //             CreateDestructableZ(treeId, pos.x, pos.y, 128.0, GetRandomDirectionDeg().asAngleDegrees().radians(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //             // createDestructable(treeId, posRight, GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //             SetTerrainType(posRight.x, posRight.y, 'Lgrd', -1, 2, 0)
        
    // // Place the rocks
    // for i = 1 to mineCount
    //     let start = kRect_PlayArea.randomPoint()
    //     let final = start.polarOffset(GetRandomDirectionDeg().asAngleDegrees(), treeOffsetDist)
    //     for offset = 0 to mineOffsetCount
    //         let pos = start.moveTowards(final, 128.0 * offset)
    //         EnumDestructablesInRectAll(Rect(pos.x - mineDestRemoveRadius, pos.y - mineDestRemoveRadius, pos.x + mineDestRemoveRadius, pos.y + mineDestRemoveRadius)) ->
    //             GetEnumDestructable().remove()
    //         CreateDestructableZ(mineId, pos.x, pos.y, 128.0, GetRandomDirectionDeg().asAngleRadians().radians(), GetRandomReal(0.9, 1.2), GetRandomInt(0, 9))
    //         // createDestructable(mineId, pos, GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //         SetTerrainType(pos.x, pos.y, 'Lrok', -1, 1, 0)
    //         if GetRandomReal(0, 1) < 0.65
    //             let posLeft = pos.polarOffset(start.angleTo(final) + (90).asAngleDegrees(), sideOffsets)
    //             EnumDestructablesInRectAll(Rect(posLeft.x - mineDestRemoveRadius, posLeft.y - mineDestRemoveRadius, posLeft.x + mineDestRemoveRadius, posLeft.y + mineDestRemoveRadius)) ->
    //                 GetEnumDestructable().remove()
    //             // createDestructable(mineId, posLeft, GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //             CreateDestructableZ(mineId, pos.x, pos.y, 128.0, GetRandomDirectionDeg().asAngleRadians().radians(), GetRandomReal(0.9, 1.2), GetRandomInt(0, 9))
    //             SetTerrainType(posLeft.x, posLeft.y, 'Lrok', -1, 1, 0)
    //         if GetRandomReal(0, 1) < 0.65
    //             let posRight = pos.polarOffset(start.angleTo(final) + (90).asAngleDegrees(), sideOffsets)
    //             EnumDestructablesInRectAll(Rect(posRight.x - mineDestRemoveRadius, posRight.y - mineDestRemoveRadius, posRight.x + mineDestRemoveRadius, posRight.y + mineDestRemoveRadius)) ->
    //                 GetEnumDestructable().remove()
    //             // createDestructable(mineId, posRight, GetRandomDirectionDeg().asAngleDegrees(), GetRandomReal(0.9, 1.4), GetRandomInt(0, 9))
    //             CreateDestructableZ(mineId, pos.x, pos.y, 128.0, GetRandomDirectionDeg().asAngleRadians().radians(), GetRandomReal(0.9, 1.2), GetRandomInt(0, 9))
    //             SetTerrainType(posRight.x, posRight.y, 'Lrok', -1, 1, 0)

/** Raises all of the terrain to hide the shallow water */
var ystart = 0
function hideAllWater()
    TerrainDeformCrater(0, 0, TILE_SIZE * mapSize, -TILE_SIZE, 0, true)
    let pathingRadius = playRadius * (TILE_SIZE / PATHING_INCREMENT).round()
    ystart = -pathingRadius
    doPeriodically(0.001) cb ->
        var yend = ystart + 8
        if yend > pathingRadius
            yend = pathingRadius
        for y = ystart to yend
            for x = -pathingRadius to pathingRadius
                SetTerrainPathable(x * PATHING_INCREMENT, y * PATHING_INCREMENT, PATHING_TYPE_BUILDABILITY, true)
                SetTerrainPathable(x * PATHING_INCREMENT, y * PATHING_INCREMENT, PATHING_TYPE_FLOATABILITY, false)
        if yend == pathingRadius
            destroy cb
            createTerrainNodes()
        else 
            ystart = yend + 1
        
function createTerrainNodes() 
    let quarterMap = (mapSize / 4) * TILE_SIZE
    let quarterPlayMap = (playRadius / 2) * TILE_SIZE
    // Upper left, snowy mountain
    SetTerrainType(-quarterMap, quarterMap, TerrainType.Lordaeron_Winter_Snow, -1, (mapSize / 4).round() + 1, 1)
    // Upper Right, ocean
    SetTerrainType(quarterMap, quarterMap, TerrainType.Sunken_Ruins_Sand, -1, (mapSize / 4).round() + 1, 1)
    // Lower Left, Forest
    SetTerrainType(-quarterMap, -quarterMap, TerrainType.Ashenvale_Grass, -1, (mapSize / 4).round() + 1, 1)
    // Lower Right, Barrens
    SetTerrainType(quarterMap, -quarterMap, TerrainType.Barrens_Desert, -1, (mapSize / 4).round() + 1, 1)
    // Center
    SetTerrainType(0, 0, TerrainType.Lordaeron_Summer_Grass, -1, (playRadius / 2).round(), 0)

    // This is going to be a simple, node-based generation algorithm. We're going to scatter out a bunch of nodes
    // that have a minimum distance between them, then call those our rooms. These will be clearings, 
    // etc in the different biomes. Then we will connect nodes to the closest other nodes. This way we gaurantee 
    // that there's paths to everywhere!
    // Start with nodes on the edges and the barriers between different biomes
    let spawnDistance = (mapSize div 2) - 6
    let spawnOffset = mapSize div 4
    nodes.add(
        new Node(0,0, (playRadius / 2).round() - genMinNodeRadius), // center area will be one huge node
        // West Spawns
        new Node(-spawnDistance, spawnOffset, 6),
        new Node(-spawnDistance, 0, 6),
        new Node(-spawnDistance, -spawnOffset, 6),
        // East Spawns
        new Node(spawnDistance, spawnOffset, 6),
        new Node(spawnDistance, 0, 6),
        new Node(spawnDistance, -spawnOffset, 6),
        // South spawns
        new Node(spawnOffset, -spawnDistance, 6),
        new Node(0, -spawnDistance, 6),
        new Node(-spawnOffset, -spawnDistance, 6),
        // North spawns
        new Node(spawnOffset, -spawnDistance, 6),
        new Node(0, -spawnDistance, 6),
        new Node(-spawnOffset, -spawnDistance, 6)
    )

    // Now add random nodes
    var attempts = 0
    // While we haven't failed too many times to place a node...
    doPeriodically(0.01) cb ->
        let newNode = new Node(GetRandomInt(-spawnDistance, spawnDistance), GetRandomInt(-spawnDistance, spawnDistance), GetRandomInt(genMinNodeRadius, genMaxNodeRadius))
        var conflict = false
        for Node node in nodes
            if newNode.getPos().distanceTo(node.getPos()) < newNode.radius + node.radius - 2
                // Too close
                conflict = true
                break
        if conflict
            attempts++ 
            destroy newNode
            if (attempts > 40)
                destroy cb
                calculateNeighbors()
        else
            // success!
            nodes.add(newNode)
            attempts = 0

function drawTerrainLine(vec2 start, vec2 goal, int radius, int terrainType)
    let distance = start.distanceTo(goal)
    let count = distance.round() div 128
    for i = 0 to count
        let pos = start.moveTowards(goal, TILE_SIZE * i)
        SetTerrainType(pos.x, pos.y, terrainType, -1, radius, 0)
    SetTerrainType(goal.x, goal.y, terrainType, -1, radius, 0)

var neighborNodeIdx = 0
function calculateNeighbors() 
    neighborNodeIdx = 0
    doPeriodically(0.001) cb ->
        let start = nodes.get(neighborNodeIdx)
        for target in nodes
            if start != target and start.getPos().distanceTo(target.getPos()) < start.radius + target.radius + neighborExtraRadius
                start.adjacent.add(target)
        neighborNodeIdx++
        if neighborNodeIdx >= nodes.size()
            destroy cb
            generateIslands()

function displayTerrain()    
    DisplayTextToForce(bj_FORCE_ALL_PLAYERS, "Nodes: " + nodes.size().toString())
    for Node node in nodes
        SetTerrainType(node.x.toReal() * TILE_SIZE, node.y.toReal() * TILE_SIZE, TerrainType.Underground_Lava, -1, node.radius, 0)
        print("Node with " + node.adjacent.size().toString() + " neighbors")
        for Node neighbor in node.adjacent
            drawTerrainLine(node.getPos() * TILE_SIZE, neighbor.getPos() * TILE_SIZE, 1, TerrainType.Underground_Lava_Cracks)

var islandStartY = 0
function generateIslands() 
    // SINK THE ISLANDS!
    islandStartY = 0
    let max = mapSize div 2
    doPeriodically(0.01) cb -> 
        var endY = islandStartY + 8
        if endY > max
            endY = max
        for y = islandStartY to endY
            for x = 0 to max
                // only deform if its not in the center circle
                if (x > (playRadius / 2) and y > (playRadius / 2)) or (vec2(x.toReal(), y.toReal()).distanceTo(vec2(0,0)) > playRadius / 2)
                    TerrainDeformCrater(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE, 0, true)
                    // update pathing
                    for pathy = 0 to 3
                        for pathx = 0 to 3
                            let posx = x * TILE_SIZE + PATHING_INCREMENT * (pathx - 1.5)
                            let posy = y * TILE_SIZE + PATHING_INCREMENT * (pathy - 1.5)
                            SetTerrainPathable(posx, posy, PATHING_TYPE_BUILDABILITY, false)
                            SetTerrainPathable(posx, posy, PATHING_TYPE_WALKABILITY, false)
                            SetTerrainPathable(posx, posy, PATHING_TYPE_FLOATABILITY, true)
        if endY == max
            destroy cb
            extrudeIslands()
        else 
            islandStartY = endY + 1
LLIterator<Node> extrudeIterator
var islandNodes = new HashSet<Node>()
function extrudeIslands()
    // Push out all the islands and the paths
    extrudeIterator = nodes.iterator()
    doPeriodically(0.001) cb ->
        if extrudeIterator.hasNext()
            let node = extrudeIterator.next()
            if node.x > 0 and node.y > 0 and node.getPos().distanceTo(vec2(0,0)) > playRadius / 2
                islandNodes.add(node)
                TerrainDeformCrater(node.x * TILE_SIZE, node.y * TILE_SIZE, node.radius * TILE_SIZE * 1.2, -TILE_SIZE * 1.5, 0, true)
                SetTerrainType(node.x * TILE_SIZE, node.y * TILE_SIZE, TerrainType.Sunken_Ruins_Grass, -1, node.radius - 1, 0)
                for y = node.radius * -4 to node.radius * 4
                    for x = node.radius * -4 to node.radius * 4
                        let pos = node.getMapPos() + vec2(x * PATHING_INCREMENT, y * PATHING_INCREMENT)
                        let maxDistSq = node.radius * node.radius * TILE_SIZE * TILE_SIZE
                        if pos.distanceToSq(node.getMapPos()) < maxDistSq
                            SetTerrainPathable(pos.x, pos.y, PATHING_TYPE_WALKABILITY, true)
                            SetTerrainPathable(pos.x, pos.y, PATHING_TYPE_BUILDABILITY, true)
                            SetTerrainPathable(pos.x, pos.y, PATHING_TYPE_FLOATABILITY, false)
        else 
            destroy cb
            extrudeIslandBridges()

function extrudeIslandBridges()            
    for Node node in islandNodes
        for neighbor in node.adjacent
            if islandNodes.has(neighbor)
                let start = node.getMapPos().moveTowards(neighbor.getMapPos(), node.radius * TILE_SIZE)
                let target = neighbor.getMapPos().moveTowards(start, neighbor.radius * TILE_SIZE)
                let count = (start.distanceTo(target) / TILE_SIZE).round()
                for i = -1 to count
                    let pos = start.moveTowards(target, TILE_SIZE * i)
                    TerrainDeformCrater(pos.x, pos.y, TILE_SIZE * 2, -TILE_SIZE / 4, 0, true)
                    SetTerrainType(pos.x, pos.y, TerrainType.Sunken_Ruins_Small_Bricks, -1, 1, 0)
                TerrainDeformCrater(target.x, target.y, TILE_SIZE * 2, -TILE_SIZE / 4, 0, true)
                SetTerrainType(target.x, target.y, TerrainType.Sunken_Ruins_Small_Bricks, -1, 2, 0)
        islandNodes.remove(node)    
    generateForest()
    
    
function generateForest()
    print("Terrain complete")
